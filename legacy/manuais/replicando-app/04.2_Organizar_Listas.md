# 04.2 — Organização de Listas por Área

> Este documento descreve as funcionalidades de vínculo entre Listas, Áreas e Colaboradores implementadas nas issues #51 e #52. Construir em cima do módulo base descrito em `04_MODULO_LISTAS.md`.

---

## Conceitos

### Área
- Representa um setor físico/operacional do restaurante (ex: "Salão", "Cozinha")
- Modelo: tabela `areas` — campos `id`, `nome`, `restaurante_id`
- Uma área pode ter vários colaboradores vinculados (tabela de junção `area_colaborador`)
- Uma área pode ter várias listas vinculadas (via FK `area_id` na tabela `listas`)

### Vínculo Lista → Área
- Campo `area_id` (Integer, nullable, FK para `areas.id`, `ondelete='SET NULL'`)
- Se a área for deletada, `lista.area_id` vira `NULL` — a lista não é deletada
- Uma lista pode não ter área (`area_id = NULL`)

### Vínculo Área → Colaboradores
- Tabela de junção `area_colaborador`: `area_id` + `usuario_id` (chaves primárias compostas)
- Relacionamento em `Area.colaboradores` → `db.relationship('Usuario', secondary=area_colaborador)`
- Backref em `Usuario.areas_atribuidas`

---

## Schema — Mudanças no Banco

### Nova tabela `area_colaborador`

```sql
CREATE TABLE area_colaborador (
    area_id   INTEGER NOT NULL REFERENCES areas(id) ON DELETE CASCADE,
    usuario_id INTEGER NOT NULL REFERENCES usuarios(id) ON DELETE CASCADE,
    PRIMARY KEY (area_id, usuario_id)
);
```

### Alteração na tabela `listas`

```sql
ALTER TABLE listas ADD COLUMN area_id INTEGER REFERENCES areas(id) ON DELETE SET NULL;
CREATE INDEX ix_listas_area_id ON listas(area_id);
```

---

## Backend — Modelos (models.py)

```python
# Tabela de junção
area_colaborador = db.Table('area_colaborador',
    db.Column('area_id', db.Integer, db.ForeignKey('areas.id', ondelete='CASCADE'), primary_key=True),
    db.Column('usuario_id', db.Integer, db.ForeignKey('usuarios.id', ondelete='CASCADE'), primary_key=True)
)

class Area(db.Model, SerializerMixin):
    # ... campos existentes ...
    colaboradores = db.relationship(
        'Usuario',
        secondary=area_colaborador,
        lazy=True,
        backref=db.backref('areas_atribuidas', lazy=True)
    )

class Lista(db.Model, SerializerMixin):
    # ... campos existentes ...
    area_id = db.Column(db.Integer, db.ForeignKey('areas.id', ondelete='SET NULL'), nullable=True, index=True)
    area    = db.relationship('Area', backref=db.backref('listas', lazy='dynamic'))
```

---

## Backend — Endpoints de Área/Colaboradores

### GET `/api/v1/areas/<area_id>/colaboradores`

Retorna os colaboradores atribuídos à área.

**Auth:** `@jwt_required()` + admin ou super admin

**Resposta 200:**
```json
{
  "area_id": 2,
  "area_nome": "Cozinha",
  "colaboradores": [
    { "id": 5, "nome": "João Silva", "email": "joao@email.com" },
    { "id": 8, "nome": "Maria Souza", "email": "maria@email.com" }
  ]
}
```

### POST `/api/v1/areas/<area_id>/colaboradores`

Substitui todos os colaboradores da área pelos informados.

**Auth:** `@jwt_required()` + admin ou super admin

**Body:**
```json
{
  "usuario_ids": [5, 8]
}
```

**Resposta 200:**
```json
{
  "area_id": 2,
  "area_nome": "Cozinha",
  "colaboradores": [
    { "id": 5, "nome": "João Silva" },
    { "id": 8, "nome": "Maria Souza" }
  ]
}
```

**Validações:**
- Apenas usuários com `role == COLLABORATOR` são aceitos
- Usuários de outro restaurante são ignorados silenciosamente

---

## Backend — Lógica de Criação de Lista (services.py)

### Prioridade: `colaborador_ids` explícito > auto-assign por área

```python
def create_lista(data, restaurante_id=None):
    # ... validações e criação do objeto Lista ...

    # Vincular colaboradores: payload explícito tem prioridade sobre auto-assign por área
    colaborador_ids = data.get('colaborador_ids')
    if colaborador_ids is not None:
        # Frontend mandou seleção explícita — usar ela
        colaboradores = []
        for uid in colaborador_ids:
            user = repositories.get_by_id(Usuario, uid)
            if user and user.role == UserRoles.COLLABORATOR:
                colaboradores.append(user)
        nova_lista.colaboradores = colaboradores
    elif area_id is not None:
        # Fallback: usar colaboradores da área (comportamento anterior)
        area = repositories.get_by_id(Area, area_id)
        if area and area.colaboradores:
            nova_lista.colaboradores = list(area.colaboradores)
```

**Regras de negócio:**
- O vínculo automático de colaboradores ocorre **apenas na criação** da lista
- Alterar a área de uma lista existente **não ressincroniza** colaboradores
- Admin pode alterar colaboradores manualmente a qualquer momento após a criação
- `colaborador_ids: []` (array vazio) é válido e cria a lista sem colaboradores

---

## Frontend — Tela de Áreas

A tela de gerenciamento de áreas (`/admin/areas`) possui um modal "Gerenciar Colaboradores" por área:

- Lista os colaboradores atualmente vinculados à área
- Permite marcar/desmarcar colaboradores com checkboxes
- Salva via `POST /v1/areas/<id>/colaboradores`
- Badge no card de área exibe o número de colaboradores vinculados

---

## Frontend — Modal de Criação de Lista

### Seção "Colaboradores" no modal "Nova Lista"

Localização: `frontend/src/features/admin/ListasCompras.tsx`

**Estados:**
```typescript
const [createCollaborators, setCreateCollaborators] = useState<number[]>([]);
const [loadingCreateColab, setLoadingCreateColab] = useState(false);
```

**Comportamento:**
1. Ao abrir o modal → `fetchAllUsers()` carrega todos os colaboradores do sistema
2. Ao selecionar uma Área → `handleCreateAreaChange()` busca colaboradores da área via `GET /v1/areas/<id>/colaboradores` e pré-marca os checkboxes
3. Ao trocar de área → seleção é recalculada para os colaboradores da nova área
4. Ao selecionar "Nenhuma" → seleção é limpa
5. Admin pode marcar/desmarcar qualquer colaborador livremente

**Handler da área:**
```typescript
const handleCreateAreaChange = async (value: string) => {
    const newAreaId = value === '' ? '' : Number(value);
    setFormData(prev => ({...prev, area_id: newAreaId}));

    if (newAreaId === '') {
        setCreateCollaborators([]);
        return;
    }
    try {
        setLoadingCreateColab(true);
        const res = await api.get(`/v1/areas/${newAreaId}/colaboradores`);
        const ids = (res.data.colaboradores || []).map((c: any) => c.id);
        setCreateCollaborators(ids);
    } catch {
        // silently ignore
    } finally {
        setLoadingCreateColab(false);
    }
};
```

**Payload de criação:**
```typescript
const payload = {
    ...formData,
    itens,
    colaborador_ids: createCollaborators  // array de IDs; vazio = sem colaboradores
};
await api.post('/v1/listas', payload);
```

**A seção de checkboxes só aparece no modal de criação (não no de edição):**
```tsx
{!editingLista && (
    <Form.Group className="mb-3">
        <Form.Label>Colaboradores</Form.Label>
        {/* Spinner durante carregamento */}
        {/* Lista scrollável de checkboxes */}
        {/* Contador de selecionados */}
    </Form.Group>
)}
```

---

## Frontend — Busca Textual + Filtro por Área na Tela de Listas

Localização: `frontend/src/features/admin/ListasCompras.tsx`

**Estados:**
```typescript
const [selectedAreaFilter, setSelectedAreaFilter] = useState<number | null>(null);
const [searchTerm, setSearchTerm] = useState('');
```

**Campo `itens_nomes` no payload do backend:**

`GET /api/v1/listas` retorna agora um campo extra por lista:
```json
{
  "id": 10,
  "nome": "Hortifruti",
  "area_id": 2,
  "itens_nomes": ["Cebola Roxa", "Batata Doce", "Alface"]
}
```
Isso permite a busca por item sem chamadas adicionais ao backend.

**Interface TypeScript:**
```typescript
interface Lista {
    // ... outros campos
    itens_nomes?: string[];  // todos os nomes dos itens ativos da lista
}
```

**Filtragem local — área + busca textual em cadeia (AND lógico):**
```typescript
const normalizeText = (text: string): string =>
    text.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');

const listasFiltradas = listas
    .filter(l => selectedAreaFilter === null || l.area_id === selectedAreaFilter)
    .filter(l => {
        if (!searchTerm) return true;
        const termo = normalizeText(searchTerm);
        const nomeMatch = normalizeText(l.nome).includes(termo);
        const itemMatch = (l.itens_nomes ?? []).some(n => normalizeText(n).includes(termo));
        return nomeMatch || itemMatch;
    });
```

**UI — campo de busca acima dos botões de área:**
```tsx
<div style={{ marginBottom: '1rem', position: 'relative' }}>
    {/* Ícone lupa (posicionado absolutamente dentro do input) */}
    <Form.Control
        type="text"
        placeholder="Buscar por nome da lista ou item..."
        value={searchTerm}
        onChange={e => setSearchTerm(e.target.value)}
    />
    {/* Botão × aparece apenas quando há texto */}
    {searchTerm && (
        <Button variant="link" onClick={() => setSearchTerm('')}>×</Button>
    )}
</div>
```

**Comportamento:**
- Busca por nome da lista OU por qualquer item contido nela (basta um match)
- Normalização remove acentos e ignora maiúsculas ("cafe" encontra "Café")
- Filtro de área e busca textual operam juntos: uma lista precisa satisfazer **ambos**
- `Todas` é sempre o primeiro botão de área e é fixo
- Clicar numa área já selecionada deseleciona (volta para "Todas")
- As áreas vêm de `GET /v1/areas` carregado no mount da tela
- Estado vazio adapta a mensagem conforme o filtro ativo: busca textual, área, ou nenhum

---

## Resumo das Issues / Features

| Issue | Feature | Arquivos |
|-------|---------|---------|
| #51 | Vínculo Lista-Área + auto-assign de colaboradores na criação | `models.py`, `services.py`, `controllers.py`, `ListasCompras.tsx`, `Areas.tsx` |
| #52 | Checkboxes de colaboradores no modal de criação com pré-seleção por área | `services.py`, `ListasCompras.tsx` |
| —   | Filtro dinâmico por área na tela `/admin/listas-compras` | `ListasCompras.tsx` |
| —   | Busca textual por nome de lista ou item (com normalização de acentos) | `services.py`, `ListasCompras.tsx` |
| —   | Otimização de performance: eliminar N+1 queries em `get_all_listas` e `obter_lista_mae` | `services.py` |
