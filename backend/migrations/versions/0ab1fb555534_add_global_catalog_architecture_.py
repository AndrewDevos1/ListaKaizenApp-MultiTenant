"""Add global catalog architecture: ListaItemRef and modify ListaMaeItem

Revision ID: 0ab1fb555534
Revises: f4c8a2d9b7e1
Create Date: 2025-12-25 23:54:33.599100

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '0ab1fb555534'
down_revision = 'f4c8a2d9b7e1'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###

    # PASSO 1: Criar tabela lista_item_ref
    op.create_table('lista_item_ref',
    sa.Column('lista_id', sa.Integer(), nullable=False),
    sa.Column('item_id', sa.Integer(), nullable=False),
    sa.Column('quantidade_atual', sa.Float(), nullable=False),
    sa.Column('quantidade_minima', sa.Float(), nullable=False),
    sa.Column('criado_em', sa.DateTime(), nullable=True),
    sa.Column('atualizado_em', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['item_id'], ['lista_mae_itens.id'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['lista_id'], ['listas.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('lista_id', 'item_id')
    )

    # PASSO 2: MIGRAR DADOS - Criar tabela temporária com itens únicos
    op.execute("""
        CREATE TABLE lista_mae_itens_temp (
            id SERIAL PRIMARY KEY,
            nome VARCHAR(255) NOT NULL UNIQUE,
            unidade VARCHAR(50) NOT NULL DEFAULT 'un',
            criado_em TIMESTAMP,
            atualizado_em TIMESTAMP
        )
    """)

    # Inserir itens únicos (consolidados por nome)
    op.execute("""
        INSERT INTO lista_mae_itens_temp (nome, unidade, criado_em, atualizado_em)
        SELECT DISTINCT ON (LOWER(TRIM(nome)))
            TRIM(nome),
            COALESCE(unidade, 'un'),
            MIN(criado_em) OVER (PARTITION BY LOWER(TRIM(nome))),
            MAX(atualizado_em) OVER (PARTITION BY LOWER(TRIM(nome)))
        FROM lista_mae_itens
        WHERE TRIM(nome) != ''
        ORDER BY LOWER(TRIM(nome)), id
    """)

    # PASSO 3: Criar referências lista ↔ item
    op.execute("""
        INSERT INTO lista_item_ref (lista_id, item_id, quantidade_atual, quantidade_minima, criado_em, atualizado_em)
        SELECT
            lmi_old.lista_mae_id,
            lmi_temp.id,
            COALESCE(lmi_old.quantidade_atual, 0),
            CASE
                WHEN COALESCE(lmi_old.quantidade_minima, 0) <= 0 THEN 1.0
                ELSE lmi_old.quantidade_minima
            END,
            NOW(),
            NOW()
        FROM lista_mae_itens lmi_old
        JOIN lista_mae_itens_temp lmi_temp
            ON LOWER(TRIM(lmi_old.nome)) = LOWER(lmi_temp.nome)
        WHERE lmi_old.lista_mae_id IS NOT NULL
    """)

    # PASSO 4: Substituir tabela antiga por nova
    # 4.1: Remover foreign key constraint temporariamente
    with op.batch_alter_table('lista_item_ref', schema=None) as batch_op:
        batch_op.drop_constraint('lista_item_ref_item_id_fkey', type_='foreignkey')

    # 4.2: Drop da tabela antiga (agora sem dependências)
    op.drop_table('lista_mae_itens')

    # 4.3: Renomear tabela temporária
    op.rename_table('lista_mae_itens_temp', 'lista_mae_itens')

    # 4.4: Recriar foreign key constraint
    with op.batch_alter_table('lista_item_ref', schema=None) as batch_op:
        batch_op.create_foreign_key('lista_item_ref_item_id_fkey', 'lista_mae_itens', ['item_id'], ['id'], ondelete='CASCADE')

    # PASSO 5: Recriar sequence
    op.execute("""
        CREATE SEQUENCE IF NOT EXISTS lista_mae_itens_id_seq;
        SELECT setval('lista_mae_itens_id_seq', (SELECT MAX(id) FROM lista_mae_itens));
        ALTER TABLE lista_mae_itens ALTER COLUMN id SET DEFAULT nextval('lista_mae_itens_id_seq');
    """)

    # NOTA: Removemos a alteração de usuarios.senha_hash pois não é relevante
    # para esta migration e causava erros de truncamento de dados

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    # NOTA: Downgrade não implementado completamente pois a migration
    # transforma dados (consolida itens duplicados). Downgrade completo
    # resultaria em perda de dados. Use backup se precisar reverter.

    # Para reverter, seria necessário:
    # 1. Recriar lista_mae_itens com estrutura antiga
    # 2. Desconsolidar itens (problema: itens foram deduplicados!)
    # 3. Deletar lista_item_ref

    raise NotImplementedError("Downgrade não suportado - use backup do banco de dados")
    # ### end Alembic commands ###
